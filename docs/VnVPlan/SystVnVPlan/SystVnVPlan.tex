\documentclass[12pt, titlepage]{article}
\newcommand{\famname}{CFS} % PUT YOUR PROGRAM NAME HERE
\usepackage{varwidth}

\usepackage[hyphens]{url}


\usepackage{lipsum}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks = true,
    breaklinks = true,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}
\usepackage{xcolor}
\usepackage{amsmath, mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{float}
\usepackage{siunitx}
\usepackage{caption}
\usepackage{pdflscape}
\usepackage{afterpage}
\usepackage{comment}
\input{../../Comments}
\usepackage[hyphenbreaks]{breakurl}
\usepackage[hyphens]{url}

\usepackage{titlesec}


\begin{document}

\title{CFS: System Verification and Validation Plan
\wss{good to see the library name in the title}\ms{Thank you :)}} 
\author{Malavika Srinivasan}
\date{\today}
	
\maketitle

\pagenumbering{roman}


\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Oct 16, 2018 & 1.0 & First draft by Malavika.\\
Oct 23, 2018 & 2.0 & Second draft by Malavika.\\
Dec 6, 2018 & 3.0 & Third draft based on suggestions from Dr.Smith.\\
Dec 23, 2018 & 4.0 & Final draft after implementation.\\

\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
	\toprule		
	\textbf{symbol} & \textbf{description}\\
	\midrule 
	T & Test\\
	MG & Module Guide\\
	MIS & Module Interface Specification\\
	\bottomrule
\end{tabular}\\
\\
Also see the table of symbols in CA at: 
\url{https://github.com/Malavika-Srinivasan/CAS741/tree/master/docs/SRS/CA.pdf}\\


\newpage

\tableofcontents

\listoftables

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
	\toprule		
	\textbf{Table name} & \textbf{description}\\
	\midrule 
	Table 1 & Requirement Traceability matrix\\
	\bottomrule
\end{tabular}\\




%\listoffigures

\wss{if you don't have any figures, you can comment out this heading}\ms{I 
commented out listoffigures}

\newpage

\pagenumbering{arabic}


This document explains the verification and validation plan to improve the 
quality of \famname{}. It is organized into different sections which gives a 
detailed description of the \famname{}, in terms of its goals, objectives, 
essential qualities and test cases for the functional and non functional 
requirements as mentioned in the CA document.



\section{General Information}

This section explains the summary of what is being tested in this document, the 
objectives of verification and validation process and the references which are 
necessary to read this document.


\subsection{Summary}

This document will summarize the plan for verification and validation of
\famname{} in compliance with the requirements specified in the CA document
found at
\sloppy
\url{https://github.com/Malavika-Srinivasan/CAS741/tree/master/docs/SRS/CA.pdf}
\wss{good to have a link to your repo.}\ms{Thank you :)}

The goal statement as found in the CA document is presented below.\\
\noindent ``Given the set of data points, the choice of software from \famname{} and the variabilities of the software the \famname{} should:

\begin{enumerate}
	
	\item Compute the parameters of the curve which is the best possible fit 
	through the set of data points.''
\end{enumerate}


\subsection{Objectives}

The goal of verification and validation is to improve the quality of the
\famname{} \wss{I recently modified the blank project template to put the
  (equivalent of) the famname command in a common file, which can be shared
  between all your files.  You might want to do the same.}\ms{Yes, using 
  it. Thanks.}and obtain confidence in the software implementation. There are 
several standards which define software quality. According to the quality model 
of ISO 9126, software quality is described as a structured set of 
characteristics namely - Functional suitability, Performance, Efficiency, 
Compatibility, Usability, Reliability, Security, Maintainability and 
Portability (\cite{ISO9126}). The qualities which are important concerning 
\famname{} are correctness(functional suitability), maintainability, 
reusability and portability. The definitions of the above mentioned qualities 
are explained below.

\wss{You still don't have lines of text that are 80 characters long (separated
  by hard returns) in the tex file.}\ms{I am so sorry, but I changed the 
  setting to hard return after you mentioned. It does go to the next line when 
  my typing reached 80 column width. I am really not sure why this happens. I 
  forgot to discuss this 
  during today's meeting. Please let me know if it still happens, I will drop 
  by sometime and see what is wrong.}

\subsubsection {Functional Suitability}

This characteristic represents the degree to which a product or system provides
functions that meet stated and implied needs when used under specified
conditions. It can be further characterized into completeness, correctness and
appropriateness. In this project, we focus only on correctness which is defined
as shown below.

\paragraph{Correctness } \wss{do you mean for this to be a subsection (not a
  paragraph), like the other subsections?}\ms{I want to be a sub characteristic 
  under correctness. I did not want to alter the sec depth as it would be 
  modifying the structure, so I used paragraph. But it was intended to be 
  subsubsubsection.}  The degree to which a product or
system provides the correct results with the needed degree of precision.

\subsubsection{Maintainability}
This characteristic represents the degree of effectiveness and efficiency with
which a product or system can be modified to improve it, correct it or adapt it
to changes in the environment, and in requirements. 

\subsubsection{Portability}
The degree of effectiveness and efficiency with which a system, product or
component can be transferred from one hardware, software or other operational
or usage environment to another. 


\subsection{References}

Throughout this document, we refer to the terminologies that have been already
explained in the CA document for Program \famname{}. The CA document can be
found at
\sloppy
\url{https://github.com/Malavika-Srinivasan/CAS741/tree/master/docs/SRS/CA.pdf} 
\wss{Reference your 
SRS.}\ms{Yes, done.}

\section{Plan}
	
\subsection{Verification and Validation Team}

\begin{enumerate}
	\item Malavika srinivasan
	\item Dr.\ Spencer Smith
	\item Hanane Zlitni
\end{enumerate}


\subsection{SRS Verification Plan}

The CA document for \famname{} will be reviewed by Dr.\ Spencer Smith
\wss{\LaTeX{} has a rule that it inserts two spaces at the end of a sentence.
  It detects a sentence as a period followed by a capital letter.  This comes
  up, for instance, with Dr. Smith.  Since the period after Dr.\ isn't actually
  the end of a sentence, you need to tell \LaTeX{} to insert one space.  You do
  this either by Dr.\ Smith (if you don't mind a line-break between Dr.\ and
  Smith), or Dr.~Spencer Smith (to force \LaTeX{} to not insert a line break).}
and my classmate Robert White.\ms{Thank you for the advice. I will keep this in 
mind for future.}

\subsection{Design Verification Plan}

My design will be verified with the help of my supervisor Dr.\ Spencer Smith and
my classmates. My MG (Module Guide) will be verified by Jennifer Garner and my 
MIS (Module Interface Specification) will be verified by Brooks MacLachlan.
 \wss{Good to list
  the specific people.  You should also split this up between the MG and the 
  MIS.}\ms{Thank you. Changes done.}

\subsection{Implementation Verification Plan}

My implementation will be verified against the tests listed in this document 
and the Unit Verification and Validation plan document. 

\subsection{Software Validation Plan}

Not Applicable \wss{why not?}\ms{I think my software can be validated against 
the content in chapter 3 and 7 of Health1997. Is that ok to write?}

\section{System Test Description}

System testing is a process in which we test the overall working of the system. The instance models in CA document will be tested here. This does not test the individual units or modules of the system. It is a black box testing approach.
	
\subsection{Tests for Functional Requirements}\label{FuncReq}

In this section, we present the test cases which are related to the functional 
requirements of \famname{}. The functional requirements can be found at \sloppy
\url{https://github.com/Malavika-Srinivasan/CAS741/tree/master/docs/SRS/CA.pdf} 
The test cases below are aimed at testing the overall working of the system 
which is represented by the functional requirements. 
\wss{It would be nice to have a blurb here to explain why the subsections below
  cover the requirements.  References to the SRS would be good.}\ms{Added}

\subsubsection{Input Testing}\label{InputTesting}

In this section, we will present the test cases for the input to \famname{}. 
The test cases are selected based on the constraints for the input data 
which is recorded as assumptions in the CA document found at  \sloppy
\url{https://github.com/Malavika-Srinivasan/CAS741/tree/master/docs/SRS/CA.pdf} 
\\
The typical constraints on the input data for \famname{} is associated with the 
data type and length of the input data. Some of the inputs such as the degree 
of the polynomial have mathematical restrictions of being a natural number. The 
test cases listed below are designed to ensure that the input data to 
\famname{} does not violate these constraints.  

\wss{It would be nice to have a blurb here to explain why the subsections below
  cover the requirements.  References to the SRS would be good.}\ms{Added 
  introductory blurb.}

\begin{enumerate}

\item{\textbf{T1a: Test case for inputs with less than 2 points 
}\\}\label{{T1a}}

Control: Automatic

Initial State: NA

Input: t=[1] , y=[2] (length 1)

Output: Error message (``Please enter at least \wss{proof read}\ms{Corrected} 2 
points'')

How test will be performed: Pytest




\item{\textbf{T1b: Test case for inputs of unequal length }\\}\label{{T1b}}

Control: Automatic

Initial State: NA

Input: t=[1,2,3] , y=[2,3,4,5] (len(t) $\ne$ len(y))

Output: Error message (``Length of input arrays must be the same'')

How test will be performed: Pytest

\ms{Please note, I used T1a and T1b for the first two cases. I did not want to 
change the numbers everywhere.}

\item{\textbf{T2: Test case for data type mismatch}\\}

Control: Automatic

Initial State: NA

Input: t=[1,2,3,4,t] , y=[2,2,3,4,5] 

Output: Error message (``Please enter only numbers'') or TypeError exception

How test will be performed: Pytest


\item{\textbf{T3: Test case for unordered inputs}\\}

Control: Automatic

Initial State: NA

Input: t=[1,2,5,4] , y=[2,0,3,4] 

Output: Error message (``Wrong input: $t_{i+1}$ must be greater than $t_i$'')

How test will be performed: Pytest



\subsubsection{Interpolation Testing}\label{InterpolationTesting}

In this section, we will represent the test cases for each access program 
present in the interpolation module. This module has access programs to find 
the coefficients of the interpolated curve through a set of points $(t_i,y_i)$ 
for $i = 0\ \text{to}\ n$ and find the value of the interpolating polynomial at 
a given `$t$' value.

In order to carry out system testing, the general test case below will be used 
by different algorithms.

\fbox{\begin{varwidth}{\textwidth}
\textbf{General test case} \\ \\
Control: Automatic\\ \\
Initial State: NA\\ \\
Input: Data points t = [0,1,2], y = [0,1,2]\\ \\
Output: [0, 1, 0] (Coefficients of t, starting from $t^{0}$.)\\ \\
How test will be performed: Pyunit\\ \\
Test case derivation: \\

To obtain a straight line between two pints, the general formula is \\
$y = mx + c$ where $m$ is the slope of the line and $c$ is the constant.\\
To compute `m', the formula below is used,\\
\begin{equation}
m = \frac{y_2-y_1}{x_2-x_1}\\
\end{equation}

Here, $(x_1,y_1)\ =\ (0,0),\ (x_2,y_2)\ =\ (1,1),\ (x_3,y_3)\ =\ (2,2)$\\

Hence applying the values of $x_1,\ x_2,\ y_1\ and\ y_2$, we get $m\ =\ 1$.\\

Applying, $m=1$, the equation ($1$), $c = 0$.\\

Therefore, the coefficients of the straight line is $[0,1]$.




\end{varwidth} }




%#######################       Monomial    ################################

\wss{It would be nice to have a blurb here to explain why the subsections below
  cover the requirements.  References to the SRS would be good.}\ms{Added 
  introductory blurb.}

\item{\textbf{T4: $I^{st}$ test case for Monomial interpolation} \\}

Please refer to the general test case presented in section 
\ref{InterpolationTesting}.


\item{\textbf{T5: ${II}^{nd}$ test case for Monomial interpolation}}\\

Control: Automatic
					
Initial State: NA
					
Input: Data points t = [-2,0,1], y = [-27,-1,0]

Output: [-1,5,-4](Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference: Page 314, example 7.1 of ~\cite{Health1997}\\


%#######################       Lagrange    ################################
					
\item{\textbf{T6: $I^{st}$ test case for Lagrange's interpolation} \\}

Control: Automatic

Initial State: NA
 
Input: Data points t = [0,1,2], y = [0,1,2]
 
Output: [0, 1, 2] (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pyunit

Test case derivation: Please refer to the general test case presented in 
section~\ref{InterpolationTesting}.

 \wss{You
    list first and second test cases, but why were they selected?  Why does the
    second test case cover something different from the first?}  \ms{The first 
    test case is for a straight line which is trivial, a line passing through 
    origin. The second test case is the one which will deal with polynomials. 
    The reason why I chose first test case was, I wanted a common test case for 
    all the approaches, I just liked the idea.}
Please refer to the general test case presented in section 
\ref{InterpolationTesting}.

\wss{You repeat this same test case several
  times, but for different algorithms.  This is a good idea, but you should
  record this in a more efficient way.  You can list the test case once and then
  reference it in the subsequent cases and simply say that it will be repeated,
  but for a different algorithm.  You could summarize a much higher number of
  test cases if you used tables.}\ms{Thanks, good idea. I listed this test 
  case as general test case and using references to point to them.}
\ms{But Lagrange coefficients are the same as y, so the general test case 
cannot be reused here. So, I am writing this again.}\\ 



\item{\textbf{T7: ${II}^{nd}$ test case for Lagrange's interpolation} \\}

Control: Automatic

Initial State: NA

Input: Data points t = [-2,0,1], y = [-27,-1,0]

Output: [-27,-1, 0] (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference: Page 314, example 7.1 of  ~\cite{Health1997}\\

%#######################       Newton    ################################

\item{\textbf{T8: $I^{st}$ test case1 for Newton's interpolation} \\}

Please refer to the general test case presented in section 
\ref{InterpolationTesting}.


\item{\textbf{T9: ${II}^{nd}$ test case for Newton's interpolation} \\}

Control: Automatic

Initial State: NA

Input: Data points t = [-2,0,1], y = [-27,-1,0]

Output: [-27, 13.0, -4.0] (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference: Page 314, example 7.1 of \cite{Health1997}\\



%#######################       Hermite Cubic     ################

\item{\textbf{T10: $I^{st}$ test case for Hermite cubic interpolation }\\}

Control: Automatic 

Initial State: NA

Input: t = [1,3], y = [2,1]

Output: [2, 1.67, 1.33, 1.0] (Coefficients of t, starting from $t^{0}$.)


How test will be performed: Pytest

Test case reference: \cite{HermiteCubic} \\

\item{\textbf{T11: ${II}^{nd}$ test case for Hermite \wss{Hermite}\ms{Changed} 
cubic 
interpolation} \\}

Control: Automatic 

Initial State: NA

Input: t = [1, 2, 4, 5], y = [2, 1, 4, 3]

Output: 
~\newline [1.0,1.0, 1.38888889, 2.0] in [1,2), (Coefficients of t, starting from $t^{0}$.)

~\newline [4.0, 4.0, 1.0, 1.0] in [2,4), (Coefficients of t, starting from $t^{0}$.)

~\newline[3.0, 3.61111111, 4.0, 4.0] in [4,5), (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference: \cite{HermiteCubic2}\\
%#######################################################

\item{\textbf{T12: $I^{st}$ test case for BSpline interpolation} \\}

Control: Automatic 

Initial State: NA

Input: t = [ 0.0, 1.2,  1.9,  3.2,  4.0,  6.5], y = [ 0.0,  2.3,  3.0,  4.3,  
2.9,  3.1]


Output: 
~\newline [0, 2.987, -0.574, 14.670,-10.325, 3.1, 0, 0, 0, 0, 0]

How test will be performed: Pytest

Test case reference: \cite{BSpline}



\item{\textbf{T13: $I^{st}$ test case for evaluating Monomial interpolation}}

Type: Automatic

Initial State: NA 

Input: [0,1], 2 

Output: 2

Test Case Derivation: Please see inputs of T4 in section \ref{InputTesting} in 
System verification and validation plan. The output of T4 is the coefficients 
of the polynomial, which is the input here and one of the input data point from 
`t' is chosen to be the input. I am using the same test case because this 
provides completeness in the sense that from the input, we obtained the 
coefficients of the polynomial and from the polynomial coefficients we obtained 
our input.

How test will be performed: Pytest



\item{\textbf{T14: ${II}^{nd}$ test case for evaluating Monomial interpolation}}

Type: Automatic

Initial State: NA 

Input: [-1, 5, 4], -2 

Output: -27

Test Case Derivation: Page 314, example 7.1 of \cite{Health1997}. 

How test will be performed: Pytest



\item{\textbf{T15: $I^{st}$ test case for evaluating Lagrange's interpolation}}

Type: Automatic

Initial State: NA 

Input: t = [0,1,2], y = [0,1,2], 2 (point of evaluation)

Output: 2

Test Case Derivation: Please see inputs of T4 in section \ref{InputTesting} in 
System verification and validation plan. The output of T4 is the coefficients 
of the polynomial, which is the input here and one of the input data point from 
`t' is chosen to be the input. I am using the same test case because this 
provides completeness in the sense that from the input, we obtained the 
coefficients of the polynomial and from the polynomial coefficients we obtained 
our input.

How test will be performed: Pytest

\item{\textbf{T16: ${II}^{nd}$ test case for evaluating Lagrange's 
interpolation}}

Type: Automatic

Initial State: NA 

Input: t = [-2, 0, 1], y = [-27, -1, 0], -2 (point of evaluation)

Output: -27

Test Case Derivation: Page 314, example 7.1 of \cite{Health1997}. 

How test will be performed: Pytest


\item{\textbf{T17: $I^{st}$ test case for evaluating Newton's interpolation}}

Type: Automatic

Initial State: NA 

Input: coeff = [0,1], t = [0, 1, 2],  2 (point of evaluation)

Output: 2

Test Case Derivation: Please see inputs of T4 in section \ref{InputTesting} in 
System verification and validation plan. The output of T4 is the coefficients 
of the polynomial, which is the input here and one of the input data point from 
`t' is chosen to be the input. I am using the same test case because this 
provides completeness in the sense that from the input, we obtained the 
coefficients of the polynomial and from the polynomial coefficients we obtained 
our input. 

How test will be performed: Pytest

\item{\textbf{T18: ${II}^{nd}$ test case for evaluating Newton's interpolation}}

Type: Automatic

Initial State: NA 

Input: t = [-2, 0, 1], coeff = [-27, 13.0, -4.0], t = [-2] 

Output: -27

Test Case Derivation: Page 314, example 7.1 of \cite{Health1997}. 

How test will be performed: Pytest



\item{\textbf{T19: $I^{st}$ test case for evaluating Hermite cubic 
interpolation}}

Type: Automatic

Initial State: NA 

Input: ~\newline 
[1,3]\ms{Points of evaluation}, [1,3]\ms{Input x values}, [2,1]\ms{y 
val}						

Output: [2,1]\ms{Output for each x value}

Test Case Derivation: \cite{HermiteCubic2}

How test will be performed: Pytest

\item{\textbf{T20: ${II}^{nd}$ test case for evaluating Hermite cubic 
interpolation}}

Type: Automatic

Initial State: NA 

Input: ~\newline 
 [1,2,4,5]\ms{Points of evaluation}, [1,2,4,5]\ms{x values}, [2, 1, 4, 
 3]\ms{y values} 				

Output: [2, 1, 4, 3]\ms{Output for each x value}

Test Case Derivation: \cite{HermiteCubic2}

How test will be performed: Pytest

\item{\textbf{T21: Test case for evaluating BSplines}}

Type: Automatic

Initial State: NA 

Input: [0.0, 1.2, 1.9, 3.2, 4.0, 6.5] \ms{points of evaluation}, [0.0, 1.2, 
1.9, 3.2, 4.0, 6.5]\ms{x values}, 
[0.0, 2.3, 3.0, 4.3, 2.9, 3.1]\ms{y values} 

Output: [ 0.0,  2.3,  3.0,  4.3,  2.9,  3.1]

Test Case Derivation: \cite{BSpline}

How test will be performed: Pytest






%#######################################################

\subsubsection{Regression Testing}\label{ResgressionTesting}



\item{\textbf{T22: $I^{st}$ test case for regression using normal equations} \\}

Control: Automatic

Initial State: NA

Input: t = [0,1,2,3,4,5,6,7,8,9,10], y = [0,1,2,3,4,5,6,7,8,9,10], deg = 1 

Output: 0,1 (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest\\

%#######################################################

\item{\textbf{T23: ${II}^{nd}$ test case for regression using normal 
equations}\\}

Control: Automatic

Initial State: NA

Input: Data points t = [1,2,3], y = [1,3,7], deg = 1

Output: -2.33333333333, 3 (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference: ~\cite{RegNormal}\\

%#######################################################

\item{\textbf{T24: ${III}^{rd}$ test case for regression using normal equations 
}\\}

Control: Automatic

Initial State: NA

Input: t = [0,200,400,600,800], y = [0.0010, 0.0015, 0.0021, 0.0051, 0.0094], degree = 2

Output: 0.00116857142857, -0.00000408571429, 0.00000001785714 (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference:~\cite{RegNormal}\\

%#######################################################


\item{\textbf{T25: $I^{st}$ test case for regression using augmented systems}\\}

Control: Automatic

Initial State: NA

Input: Data points t = [0,1,2,3,4,5,6,7,8,9,10], y = [0,1,2,3,4,5,6,7,8,9,10], degree = 1 

Output: 0,1 (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest\\

\item{\textbf{T26: ${II}^{nd}$ test case for regression using augmented 
systems}\\}

Control: Automatic

Initial State: NA

Input: Data points t = [1,2,3,4], y = [5,3,2,1], deg = 1

Output: [6,-1.3] (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference: \cite{RegAugmented}\\


\item{\textbf{T27: ${I}^{st}$ test case for regression using orthogonal 
transformations}\\}

Control: Automatic

Initial State: NA

Input: Data points t = [0,1,2,3,4,5,6,7,8,9,10], y = [0,1,2,3,4,5,6,7,8,9,10] 

Output: [0,1,0,0,0,0,0,0,0,0,0] (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest\\


\item{\textbf{T28: ${II}^{nd}$ test case for regression using orthogonal 
transformations}\\}

Control: Automatic

Initial State: NA

Input: Data points t = [1,2,3,4], y = [5,3,2,1] , degree = 1

Output: [9, -5.3333, 1.5, -0.1667] (Coefficients of t, starting from $t^{0}$.)

How test will be performed: Pytest

Test case reference: Page $4$ and $5$ of \cite{RegOrthogonal}\\

\item{\textbf{T29: Test case for evaluating Regression}}

Control: Automatic

Initial State: NA

Input: [-8, 4, 7],-2

Output: 12

How test will be performed: Pytest

Test case reference: \cite{RegAugmented}\\



\subsection{Tests for Nonfunctional Requirements}\label{NFRTesting}



\item{\textbf{T20: Test case for correctness}\\}

Type: Nonfunctional, Automatic, Parallel testing - Included as part of test 
folder. Please see test\_correctness.py.
					
Initial State: NA
					
Input/Condition: Results from Matlab or Python libraries for T4,T5,T6 ... T29 
will be manually compared using relative error by the formula below. \ms{I am 
saying python libraries because most of them are implemented from scratch. For 
some of them, I may be writing a wrapper, for which I will use matlab for 
comparison.}

Note: Please note that python does not provide coefficients of interpolation. 
So, I tested them by evaluating the interpolant at point of interest.
\begin{equation*}
err = \frac{val_{CFS} - val_{Matlab}}{val_{CFS}}
\end{equation*}

\begin{equation*}
err < Admissible\_error
\end{equation*}

\wss{good test case}\ms{Thank you :)}

$ADMISS\_ERR$ is available in appendix section.  \wss{This isn't a good
symbol.  A constant like this should be in all caps and it won't space out
properly.  Use something like $\mathit{ADMISS\_ERR}$.}\ms{Changes made.}\\
				
Output/Result: The output will be the maximum relative error of all the teest 
cases.
\wss{The output should be the expected result. Since you are summarizing 
multiple test cases at once, you could think of your
  output as a table of all of the relative errors, or you could report the
  maximum relative error (infinity norm.)}\ms{Changes made.}
					
How test will be performed: Manual
				

				
%#######################################################					
\item{\textbf{T21: Test case for maintainability}\\}

Type: Nonfunctional, Manual
					
Initial State: NA
					
Input: Module guide, Module Interface specification

Steps: 
\begin{enumerate}
	\item Choose participants
	\item Assign a task such as changing the secret of a module
	\item Give the participants MG and MIS
	\item Ask them to find, which module undergoes change.
\end{enumerate}

This will help in accessing the maintainability of the software by measuring the ability to undergo change.\\
~\newline	
Output: Pass/ Fail\\
					
How test will be performed: Manual \wss{I like this test case 
experiment.}\ms{Thank you :). } 


%#######################################################

\item{\textbf{T22: Test case for Portability}\\}

Type: Nonfunctional, Manual

Initial State: NA

Input/Condition: Try and run \famname{} in Mac, Windows and Linux using virtual machines.

Output/Result: Pass/Fail

How test will be performed: Manual

\end{enumerate}

\subsection{Traceability Between Test Cases and Requirements}

The following table shows the traceability mapping for test cases, instance models and the requirements. 

\begin{table} [H]
	\caption{Requirements Traceability Matrix}
	\label{Table:Table_Traceability}  
	\begin{tabular}{|c|p{5cm}|p{5cm}|}
		\hline	
		\textbf{Test Number} & \textbf{Instance Models} & \textbf{CA Requirements}\\
		\hline 
		T1(a,b)&         & R1, R3       \\ \hline
		T2&         & R1, R2       \\ \hline
		T3&         & R1, R3       \\ \hline
		
		T4& IM1,IM3 & R4, R5, R6, R9, R10   \\ \hline
		T5& IM1,IM3& R4, R5, R6, R9, R10   \\ \hline
		
		T6& IM1, IM4& R4, R5, R6, R9, R10   \\ \hline
		T7& IM1, IM4& R4, R5, R6, R9, R10   \\ \hline
		
		T8& IM1,IM5& R4, R5, R6, R9, R10   \\ \hline
		T9& IM1, IM5& R4, R5, R6, R9, R10   \\ \hline
		
		
		T10& IM2, IM6& R4, R5, R7, R9, R10     \\ \hline
		T11& IM2, IM6& R4, R5, R7, R9, R10     \\ \hline
		
		
		T12& IM2, IM7& R4, R5, R7, R9, R10     \\ \hline
		
		
		T13& IM8     & R4, R8, R9, R10  \\ \hline
		T14& IM8     & R4, R8, R9, R10  \\ \hline
		T15& IM8     & R4, R8, R9, R10  \\ \hline
		
		
		T16& IM9     & R4, R8, R9, R10    \\ \hline
		T17& IM9     & R4, R8, R9, r10     \\ \hline
		
		T18& IM10    & R4, R8, R9, R10    \\ \hline
		T19& IM10    & R4, R8, R9, R10    \\ \hline
		
		T20&         & R12\\ \hline
		T21&         & R13\\ \hline
		T22&         & R11\\ \hline
		
	\end{tabular}\\
\end{table}




\section{Static Verification Techniques}

Code walkthrough was planned, but could not be done due to lack of time.

				


\newpage

\section{Appendix}



\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.
\begin{itemize}
	\item $ADMISS\_ERR = 1 \times 10^{-1}$
\end{itemize}

\wss{You should write numbers properly $1 \times 10^{-1}$}\ms{Changed}

%\subsection{Usability Survey Questions?}

%\wss{This is a section that would be appropriate for some projects.}


\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}


\end{document}